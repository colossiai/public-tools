# 字段掩码，让前端决定后端返回什么


**字段掩码（Field Mask）**就是：**由前端声明“我要哪些字段”**，后端只返回这些字段，从而减少 payload、提升性能、并让接口更灵活。

这是一个成熟且常用的设计，在 REST / gRPC / GraphQL 中都有对应形态。

---

## 一、核心思想

> **客户端显式声明所需字段集合，服务端按声明裁剪响应**

而不是：

* 后端固定返回一大坨 JSON
* 或为不同前端写 N 个接口 / DTO

---

## 二、常见实现方式

### ✅ 1. REST + `fields` 查询参数（最常见）

```http
GET /users/123?fields=id,name,avatar
```

响应：

```json
{
  "id": 123,
  "name": "Eric",
  "avatar": "https://..."
}
```

#### 嵌套字段

```http
GET /orders/1?fields=id,total,user.id,user.name
```

```json
{
  "id": 1,
  "total": 100,
  "user": {
    "id": 123,
    "name": "Eric"
  }
}
```

📌 **Google APIs / Stripe / GitHub 都用这种**

---

### ✅ 2. Protobuf / gRPC `google.protobuf.FieldMask`（最标准）

```proto
import "google/protobuf/field_mask.proto";

message GetUserRequest {
  int64 id = 1;
  google.protobuf.FieldMask field_mask = 2;
}
```

前端传：

```json
{
  "id": 123,
  "fieldMask": {
    "paths": ["id", "name", "profile.avatar"]
  }
}
```

这是**字段掩码的官方定义来源**，REST 方案很多都是它的思想简化版。

---

### ✅ 3. GraphQL（字段掩码的“终极形态”）

```graphql
query {
  user(id: 123) {
    id
    name
    avatar
  }
}
```

* 前端完全控制字段
* 后端只 resolve 被请求的字段

📌 **代价**：复杂度、缓存、运维成本更高
📌 **适合**：BFF / 超复杂前端

---

## 三、后端设计（以 Go / Gin 为例）

### 1️⃣ 定义字段白名单（非常重要）

```go
var allowedUserFields = map[string]bool{
	"id": true,
	"name": true,
	"email": false, // 禁止前端拿
	"avatar": true,
}
```

⚠️ **永远不要直接 trust 前端字段**

---

### 2️⃣ 解析字段参数

```go
fields := strings.Split(c.Query("fields"), ",")
```

校验：

```go
for _, f := range fields {
	if !allowedUserFields[f] {
		return error("invalid field")
	}
}
```

---

### 3️⃣ 裁剪响应（DTO / map / struct tag）

#### 简单版（map 裁剪）

```go
func Pick(src map[string]any, fields []string) map[string]any {
	dst := map[string]any{}
	for _, f := range fields {
		if v, ok := src[f]; ok {
			dst[f] = v
		}
	}
	return dst
}
```

#### 高级版

* 反射 + struct tag
* JSON streaming encoder
* 直接下推到 SQL（只 select 必要列）

---

## 四、性能 & 架构建议（很关键）

### ✅ 字段掩码的三层收益

| 层    | 优化点                             |
| ---- | ------------------------------- |
| HTTP | payload 更小                      |
| JSON | 少 marshal                       |
| DB   | `SELECT id,name` 而不是 `SELECT *` |

👉 **最佳实践：字段掩码要能下推到 DB 层**

---

## 五、安全 & 设计红线 ⚠️

### ❌ 不要做的事

* ❌ 让前端随意访问内部字段
* ❌ 用字段掩码绕过鉴权
* ❌ 把“是否能看”交给前端

### ✅ 正确模型

```text
权限校验  →  可访问字段集合  →  字段掩码裁剪
```

---

## 六、什么时候该用字段掩码？

✅ 适合：

* 多前端（Web / App / BFF）
* 高性能 API
* 公共 API
* 列表接口（特别重要）

❌ 不适合：

* 极简单 CRUD
* 内部一次性脚本接口

---

## 七、你可以这样总结给团队

> 字段掩码不是“前端控制后端”，
> 而是 **后端给前端一个“安全的可选集合”**，
> 前端只是在这个集合里做选择。

如果你愿意，我可以：

* 给你一个 **完整 Gin middleware + SQL 下推示例**
* 或设计一个 **类似 RFC 风格的 `?fields=` 规范**
* 或对比 **字段掩码 vs 多 DTO vs GraphQL**

你更想往哪一步走？
