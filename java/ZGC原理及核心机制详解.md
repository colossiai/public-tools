ZGC（Z Garbage Collector）是一款由Oracle在JDK 11中引入的低延迟垃圾回收器，它的设计目标是在支持TB级别大堆内存的同时，将垃圾回收的停顿时间控制在**十毫秒以内**，并且停顿时间不会随着堆的增大或活跃对象的增多而增加。ZGC最初作为实验性功能，在JDK 15中宣布生产就绪，并在JDK 17中成为了默认的垃圾回收器。

为了让你能快速把握ZGC的全貌，下面这个表格汇总了其核心机制和特点。

| 维度         | ZGC的核心机制与特点                                                                                                 |
| :----------- | :------------------------------------------------------------------------------------------------------------------- |
| **设计目标**   | 支持TB级堆内存；停顿时间<10ms；停顿时间不随堆或活跃对象增长                                  |
| **堆内存布局** | 基于**Region**（小型2MB，中型32MB，大型动态）                                                        |
| **核心技术**   | **着色指针**（Colored Pointers） 和 **读屏障**（Load Barriers）                 |
| **运作特点**   | 标记、转移、重定位阶段几乎全并发；仅有三次短暂STW（初始标记、再标记、初始转移），且时间与GC Roots数量成正比，与堆大小无关 |
| **主要优缺点** | **优点**：极低停顿，支持大堆<br>**缺点**：可能更高的CPU使用，高分配速率下可能分配停顿                               |

### 🔍 ZGC的核心技术

ZGC实现低延迟的目标，主要依赖于两项关键技术：

- **着色指针（Colored Pointers）**：
  - 着色指针技术直接将**少量额外的元数据信息（标记位）存储在64位对象指针本身**上。在Linux/x86-64平台上，ZGC利用了64位指针中未被使用的**高4位**来存储标记信息。
  - 这4个标志位分别是：**Marked0**、**Marked1**（用于交替标记存活对象）、**Remapped**（表示对象已重定位）和**Finalizable**（与终结器相关）。
  - 这样做的好处是，GC线程**标记对象时无需直接访问对象内存**，只需操作指针，速度更快。同时，当Region中的存活对象被移走，该Region可**立即被释放和重用**，而不必等待所有引用都被更新。

- **读屏障（Load Barriers）**：
  - 读屏障是JVM在应用线程**从堆内存读取对象引用时**插入的一小段代码。
  - 它的主要作用是在并发转移阶段，当应用线程访问一个**已被移动的对象**时，读屏障会**检测到指针的"Remapped"标志未设定**（通过着色指针）。然后，它会**通过查询转发表（Forwarding Table）找到对象的新地址，并自动更新引用**，使其直接指向新对象。ZGC称此特性为指针的"**自愈**"（Self-Healing）能力。

### 🔄 ZGC的工作流程

ZGC的垃圾回收周期主要包括以下几个阶段，其中大部分阶段都是与应用程序线程并发执行的：

1.  **并发标记（Concurrent Mark）**：
    - 从GC Roots出发，遍历对象图，标记所有可达对象。ZGC通过**着色指针中的Marked0或Marked1位**来标识存活对象。
    - 这个阶段使用了**两个标记位（M0和M1）交替进行**，以区分连续的垃圾收集周期。

2.  **并发转移准备（Concurrent Prepare for Relocate）**：
    - 这个阶段会**统计并确定本次收集需要清理（重分配）的Region集合**，即重分配集（Relocation Set）。

3.  **并发转移（Concurrent Relocate）**：
    - 这是ZGC最核心的阶段，它会**将重分配集中存活的对象复制到新的Region中**。
    - 在转移过程中，如果应用线程访问了被移动的对象，**读屏障会介入并进行指针的"自愈"**，将访问转发到新对象并更新引用。

4.  **并发重映射（Concurrent Remap）**：
    - 这个阶段的任务是**修正堆中所有指向旧对象地址的引用**，让它们指向新地址。
    - 为了效率，ZGC巧妙地将这个工作**合并到了下一次垃圾收集周期的并发标记阶段**中一同完成。

### ⚙️ 启用与配置ZGC

要启用ZGC，你需要在JVM启动参数中加入以下选项：

```bash
-XX:+UseZGC
```

此外，还有一些常见的调优参数：

- **`-Xmx`**：设置堆的最大容量，例如 `-Xmx10G`。
- **`-XX:ConcGCThreads`**：设置并发GC线程的数量。
- **`-XX:ParallelGCThreads`**：设置并行GC线程的数量。

### ⚖️ ZGC的优缺点

- **优点**：
  - **极低的停顿时间**：这是ZGC最显著的优势，非常适合对**延迟敏感的应用**，如实时交易系统、微服务等。
  - **出色的可扩展性**：能够高效管理**TB级别的堆内存**，且停顿时间不会随之增长。

- **缺点与挑战**：
  - **CPU开销**：并发执行GC任务会**占用一部分CPU资源**，可能对应用的整体吞吐量产生轻微影响（通常设计目标为影响小于15%）。
  - **内存分配压力**：如果对象的**分配速率过快**，超过了并发回收的速度，可能会导致**分配停顿**（Allocation Stall）。
  - **浮动垃圾**：由于是并发进行，在GC过程中产生的垃圾（浮动垃圾）只能留到下一次回收。

### 💎 总结

ZGC通过其革命性的**着色指针和读屏障技术**，实现了垃圾回收过程中**标记、转移和重映射阶段的高并发执行**，从而将STW停顿降至极低水平。虽然它可能会以轻微的CPU和吞吐量开销为代价，但对于追求低延迟、使用大堆内存的现代Java应用而言，ZGC是一个非常强大的选择。

希望以上解释能帮助你理解ZGC。如果你对特定场景下的性能表现或者更深入的调优细节感兴趣，我很乐意与你进一步探讨。