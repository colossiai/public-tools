# 这 13 个 Go 问题才是真正区分 10x 工程师的关键


original blog:
https://mp.weixin.qq.com/s/x8miXvhObFp0pQcgW5yCUA


## Question 1 — 如何发现 goroutine 泄漏，并修掉它？


修复示例：使用 context 控制生命周期

```go
// fixed example
func fFixed(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                return
            default:
            }
        }
    }()
}
```


## Question 2 — 如何在 Go 中找到 CPU 热点（hot path）并优化？

示例：pprof CPU 分析

```go
// run with
// go test -bench=. -benchmem
// or run binary and use pprof
import "net/http/pprof"

func main() {
    go func(){ http.ListenAndServe(":6060", nil) }()
    // app work
}
```

## Question 3 — 如何避免垃圾回收（GC）导致的 Stop-The-World 延迟？


简短回答思路

- 减少内存分配（alloc）
- 使用 sync.Pool 复用 buffer / 大对象
- 避免大量“大、短命”对象


示例：用 sync.Pool 复用缓冲区

```go
var bufPool = sync.Pool{
    New: func() interface{} { return make([]byte, 0, 4096) },
}

func write(w io.Writer, b []byte) {
    buf := bufPool.Get().([]byte)
    buf = append(buf[:0], b...)
    w.Write(buf)
    bufPool.Put(buf)
}
```

## Question 4 — 如何为“高写入频率”的 map 设计锁策略？

简短答案

用 sharded map（分片 map）减少锁竞争。

## Question 5 — 什么时候用 channel，什么时候用 sync/atomic？

简短答案

- channel： 适合工作流 / pipeline / 工作队列 / 所有权转移
- mutex / atomic： 适合热点共享状态，性能优先的计数/标记

## Question 6 — 如何实现“优雅关闭”（graceful shutdown）和连接 drain？


为什么重要：

直接 kill 进程 → 正在处理的请求被硬切 → 半截响应、用户错误、数据丢失。  
示例：HTTP 服务的优雅关闭

```go
srv := &http.Server{ Addr: ":8080" }

ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
defer stop()

go func(){ srv.ListenAndServe() }()

<-ctx
srv.Shutdown(context.Background())
```

问题： 收到中断信号后直接退出，没给 inflight 请求收尾。  
改变： 使用 Server.Shutdown + context，等待现有请求执行完成。  
结果： 灰度发布、滚动更新时，不再产生部分响应或连接被硬断的问题。  

## Question 7 — 如何构建高性能 JSON 响应编码？


简短回答.  
- 大数组用 流式编码
- 避免在热点路径使用反射-heavy 的编码方式
- 优化对象结构，减少不必要字段


示例：流式 JSON 编码

```go
enc := json.NewEncoder(w)
enc.SetEscapeHTML(false)
enc.Encode(obj)
```

## Question 8 — 如何衡量并诊断锁竞争（lock contention）？

为什么重要：  
锁竞争高 = 系统扩展性严重受限。

简短回答.  
- 使用 runtime/trace 或 pprof 的 blocking profile。
- 分析 block 时间、堆栈，定位哪把锁是罪魁祸首。


示例：打开 block profile

```go
// enable blocking profile
runtime.SetBlockProfileRate(1)
```


然后通过 pprof 抓取 blocking profile，分析：  
- 哪个 mutex
- 哪个调用栈
- 哪个热点路径

问题： 某个锁占用时间太长，其他 goroutine 饥饿等待。  
改变： 缩小临界区，把不必在锁里的工作挪出去。  
结果： 延迟抖动大幅下降，吞吐上升。  

## Question 9 — 如何把高延迟操作隔离出“快路径”（fast path）？

简短回答

- 慢 IO 走后台任务 / 消息队列
- 快路径只做必要校验和排队，不做重 IO
- 请求可立刻返回“已接受（202）”等状态


示例：异步处理

```go
// fast path returns immediately
func handle(rw http.ResponseWriter, req *http.Request) {
    id := startBackgroundTask(req)
    rw.WriteHeader(http.StatusAccepted)
    rw.Write([]byte(id))
}
```

## Question 10 — 如何正确安全地使用原子操作（atomic）做计数？

示例：原子计数器

```go
var cnt uint64

func inc() { atomic.AddUint64(&cnt, 1) }

func get() uint64 { return atomic.LoadUint64(&cnt) }
```

## Question 11 — 如何设计对 GC 友好的 cache？

为什么重要：  
大型缓存是 GC 和内存的重灾区。  
设计不当 → 长暂停 + 内存放大。  

简短回答.  
- 尽量使用 值类型，减少指针链
- 使用 TTL + 容量限制
- 必要时用 off-heap（如 bigcache、外部 Redis 等）

## Question 12 — 如何在服务之间实现有效的背压（backpressure）？


为什么重要：  
没有背压机制，上游持续灌请求 → 队列爆炸 → 系统一起跪。

简短回答.  
- 用队列容量代表当前系统能接收的工作量
- 队列满则拒绝：早失败优于迟崩溃
- 可以通过头部 / 协议传播负载信息

示例：简单背压队列

```go
select {
case q <- req:
    // accepted
default:
    http.Error(w, "service busy", http.StatusServiceUnavailable)
}
```

问题： 服务对所有请求照单全收，队列无限长，延迟和内存都失控。  
改变： 当队列满时立即返回 503，避免积压。  
结果： 系统保持可用性，故障模式变得可预测且可观测。  

## Question 13 — 如何区分 CPU-bound 与 IO-bound 工作的延迟模型？

为什么重要：  
两者需要完全不同的调度策略。


简短回答.  
- IO-bound： 多开 goroutine，可以轻松几千几万，让 CPU 保持低到中等利用率
- CPU-bound： goroutine 数量 ≈ CPU 核数（GOMAXPROCS），避免调度开销过大


## 面试用架构图（可直接 copy-paste）

```
Client
  |
  v
[ Load Balancer ]
  |
  v
[ Frontend API cluster ] ---> [ Auth service ]
  |                              |
  |                              v
  v                          [ Token store ]
[ Dispatcher ] --------------> [ Queue ]
  |                             |
  v                             v
[ Worker pool ] <---[ Cache ]<--[ DB replica ]
  |
  v
[ Metrics and Tracing ]
```


在面试讲解时，可以按这个顺序展开：   

• 哪些地方需要 backpressure（例如队列入口）.  
• 哪些组件必须支持 graceful shutdown.  
• 哪些服务对 延迟敏感（例如 Frontend API）.  
• 哪些部分可以 异步化 / 后台处理.  
• 指出 Metrics & Tracing 的作用：如何定位瓶颈和故障.  

## 面试策略（非常关键）

* 一上来先问清楚 约束条件：   
    - QPS？   
    - p99/p999 延迟目标？   
    - 容忍的故障范围（blast radius）？   


回答时，不要只说“我会这样优化”，要提出一个可验证的实验：  
    • 我会先 profile.  
    • 找到热点.  
    • 改某个点.  
    • 再做前后对比.  
    • 给出数据.  

• 展现出两种能力：  
    • 战术能力（写代码、解决具体问题）.  
    • 架构判断（知道往哪儿优化、怎么权衡）.  